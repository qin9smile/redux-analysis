{"version":3,"file":"redux.min.js","sources":["../src/utils/symbol-observable.ts","../src/utils/actionTypes.ts","../src/utils/isPlainObject.ts","../src/combineReducers.ts","../src/bindActionCreators.ts","../src/compose.ts","../src/applyMiddleware.ts","../src/createStore.ts"],"sourcesContent":["declare global {\n  interface SymbolConstructor {\n    readonly observable: symbol\n  }\n}\n\nconst $$observable = /* #__PURE__ */ (() =>\n  (typeof Symbol === 'function' && Symbol.observable) || '@@observable')()\n\nexport default $$observable\n","/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\n\nconst randomString = () =>\n  Math.random().toString(36).substring(7).split('').join('.')\n\nconst ActionTypes = {\n  INIT: `@@redux/INIT${/* #__PURE__ */ randomString()}`,\n  REPLACE: `@@redux/REPLACE${/* #__PURE__ */ randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n}\n\nexport default ActionTypes\n","/**\n * @param obj The object to inspect.\n * @returns True if the argument appears to be a plain object.\n */\nexport default function isPlainObject(obj: any): boolean {\n  if (typeof obj !== 'object' || obj === null) return false\n\n  let proto = obj\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto)\n  }\n\n  return Object.getPrototypeOf(obj) === proto\n}\n","import { Reducer } from './types/reducers'\nimport { AnyAction, Action } from './types/actions'\nimport ActionTypes from './utils/actionTypes'\nimport warning from './utils/warning'\nimport isPlainObject from './utils/isPlainObject'\nimport {\n  ReducersMapObject,\n  StateFromReducersMapObject,\n  ActionFromReducersMapObject\n} from './types/reducers'\nimport { CombinedState } from './types/store'\n\nfunction getUndefinedStateErrorMessage(key: string, action: Action) {\n  const actionType = action && action.type\n  const actionDescription =\n    (actionType && `action \"${String(actionType)}\"`) || 'an action'\n\n  return (\n    `Given ${actionDescription}, reducer \"${key}\" returned undefined. ` +\n    `To ignore an action, you must explicitly return the previous state. ` +\n    `If you want this reducer to hold no value, you can return null instead of undefined.`\n  )\n}\n\nfunction getUnexpectedStateShapeWarningMessage(\n  inputState: object,\n  reducers: ReducersMapObject,\n  action: Action,\n  unexpectedKeyCache: { [key: string]: true }\n) {\n  const reducerKeys = Object.keys(reducers)\n  const argumentName =\n    action && action.type === ActionTypes.INIT\n      ? 'preloadedState argument passed to createStore'\n      : 'previous state received by the reducer'\n\n  if (reducerKeys.length === 0) {\n    return (\n      'Store does not have a valid reducer. Make sure the argument passed ' +\n      'to combineReducers is an object whose values are reducers.'\n    )\n  }\n\n  if (!isPlainObject(inputState)) {\n    const match = Object.prototype.toString\n      .call(inputState)\n      .match(/\\s([a-z|A-Z]+)/)\n    const matchType = match ? match[1] : ''\n    return (\n      `The ${argumentName} has unexpected type of \"` +\n      matchType +\n      `\". Expected argument to be an object with the following ` +\n      `keys: \"${reducerKeys.join('\", \"')}\"`\n    )\n  }\n\n  const unexpectedKeys = Object.keys(inputState).filter(\n    key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach(key => {\n    unexpectedKeyCache[key] = true\n  })\n\n  if (action && action.type === ActionTypes.REPLACE) return\n\n  if (unexpectedKeys.length > 0) {\n    return (\n      `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +\n      `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` +\n      `Expected to find one of the known reducer keys instead: ` +\n      `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`\n    )\n  }\n}\n\nfunction assertReducerShape(reducers: ReducersMapObject) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key]\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      )\n    }\n\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      }) === 'undefined'\n    ) {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle ${ActionTypes.INIT} or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      )\n    }\n  })\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @template S Combined state object type.\n *\n * @param reducers An object whose values correspond to different reducer\n *   functions that need to be combined into one. One handy way to obtain it\n *   is to use ES6 `import * as reducers` syntax. The reducers may never\n *   return undefined for any action. Instead, they should return their\n *   initial state if the state passed to them was undefined, and the current\n *   state for any unrecognized action.\n *\n * @returns A reducer function that invokes every reducer inside the passed\n *   object, and builds a state object with the same shape.\n */\nexport default function combineReducers<S>(\n  reducers: ReducersMapObject<S, any>\n): Reducer<CombinedState<S>>\nexport default function combineReducers<S, A extends Action = AnyAction>(\n  reducers: ReducersMapObject<S, A>\n): Reducer<CombinedState<S>, A>\nexport default function combineReducers<M extends ReducersMapObject<any, any>>(\n  reducers: M\n): Reducer<\n  CombinedState<StateFromReducersMapObject<M>>,\n  ActionFromReducersMapObject<M>\n>\nexport default function combineReducers(reducers: ReducersMapObject) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers: ReducersMapObject = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // This is used to make sure we don't warn about the same\n  // keys multiple times.\n  let unexpectedKeyCache: { [key: string]: true }\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError: Error\n  try {\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  return function combination(\n    state: StateFromReducersMapObject<typeof reducers> = {},\n    action: AnyAction\n  ) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState: StateFromReducersMapObject<typeof reducers> = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    hasChanged =\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\n    return hasChanged ? nextState : state\n  }\n}\n","import { Dispatch } from './types/store'\nimport {\n  AnyAction,\n  ActionCreator,\n  ActionCreatorsMapObject\n} from './types/actions'\n\nfunction bindActionCreator<A extends AnyAction = AnyAction>(\n  actionCreator: ActionCreator<A>,\n  dispatch: Dispatch\n) {\n  return function (this: any, ...args: any[]) {\n    return dispatch(actionCreator.apply(this, args))\n  }\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nexport default function bindActionCreators<A, C extends ActionCreator<A>>(\n  actionCreator: C,\n  dispatch: Dispatch\n): C\n\nexport default function bindActionCreators<\n  A extends ActionCreator<any>,\n  B extends ActionCreator<any>\n>(actionCreator: A, dispatch: Dispatch): B\n\nexport default function bindActionCreators<\n  A,\n  M extends ActionCreatorsMapObject<A>\n>(actionCreators: M, dispatch: Dispatch): M\nexport default function bindActionCreators<\n  M extends ActionCreatorsMapObject,\n  N extends ActionCreatorsMapObject\n>(actionCreators: M, dispatch: Dispatch): N\n\nexport default function bindActionCreators(\n  actionCreators: ActionCreator<any> | ActionCreatorsMapObject,\n  dispatch: Dispatch\n) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, instead received ${\n        actionCreators === null ? 'null' : typeof actionCreators\n      }. ` +\n        `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\n    )\n  }\n\n  const boundActionCreators: ActionCreatorsMapObject = {}\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  return boundActionCreators\n}\n","type Func<T extends any[], R> = (...a: T) => R\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for the\n * resulting composite function.\n *\n * @param funcs The functions to compose.\n * @returns A function obtained by composing the argument functions from right\n *   to left. For example, `compose(f, g, h)` is identical to doing\n *   `(...args) => f(g(h(...args)))`.\n */\nexport default function compose(): <R>(a: R) => R\n\nexport default function compose<F extends Function>(f: F): F\n\n/* two functions */\nexport default function compose<A, T extends any[], R>(\n  f1: (a: A) => R,\n  f2: Func<T, A>\n): Func<T, R>\n\n/* three functions */\nexport default function compose<A, B, T extends any[], R>(\n  f1: (b: B) => R,\n  f2: (a: A) => B,\n  f3: Func<T, A>\n): Func<T, R>\n\n/* four functions */\nexport default function compose<A, B, C, T extends any[], R>(\n  f1: (c: C) => R,\n  f2: (b: B) => C,\n  f3: (a: A) => B,\n  f4: Func<T, A>\n): Func<T, R>\n\n/* rest */\nexport default function compose<R>(\n  f1: (a: any) => R,\n  ...funcs: Function[]\n): (...args: any[]) => R\n\nexport default function compose<R>(...funcs: Function[]): (...args: any[]) => R\n\nexport default function compose(...funcs: Function[]) {\n  if (funcs.length === 0) {\n    // infer the argument type so it is usable in inference down the line\n    return <T>(arg: T) => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args: any) => a(b(...args)))\n}\n","import compose from './compose'\nimport { Middleware, MiddlewareAPI } from './types/middleware'\nimport { AnyAction } from './types/actions'\nimport { StoreEnhancer, StoreCreator, Dispatch } from './types/store'\nimport { Reducer } from './types/reducers'\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param middlewares The middleware chain to be applied.\n * @returns A store enhancer applying the middleware.\n *\n * @template Ext Dispatch signature added by a middleware.\n * @template S The type of the state supported by a middleware.\n */\nexport default function applyMiddleware(): StoreEnhancer\nexport default function applyMiddleware<Ext1, S>(\n  middleware1: Middleware<Ext1, S, any>\n): StoreEnhancer<{ dispatch: Ext1 }>\nexport default function applyMiddleware<Ext1, Ext2, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 }>\nexport default function applyMiddleware<Ext1, Ext2, Ext3, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>,\n  middleware3: Middleware<Ext3, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 }>\nexport default function applyMiddleware<Ext1, Ext2, Ext3, Ext4, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>,\n  middleware3: Middleware<Ext3, S, any>,\n  middleware4: Middleware<Ext4, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 & Ext4 }>\nexport default function applyMiddleware<Ext1, Ext2, Ext3, Ext4, Ext5, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>,\n  middleware3: Middleware<Ext3, S, any>,\n  middleware4: Middleware<Ext4, S, any>,\n  middleware5: Middleware<Ext5, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 & Ext4 & Ext5 }>\nexport default function applyMiddleware<Ext, S = any>(\n  ...middlewares: Middleware<any, S, any>[]\n): StoreEnhancer<{ dispatch: Ext }>\nexport default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer<any> {\n  return (createStore: StoreCreator) => <S, A extends AnyAction>(\n    reducer: Reducer<S, A>,\n    ...args: any[]\n  ) => {\n    const store = createStore(reducer, ...args)\n    let dispatch: Dispatch = () => {\n      throw new Error(\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.'\n      )\n    }\n\n    const middlewareAPI: MiddlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    }\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose<typeof dispatch>(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n","import $$observable from './utils/symbol-observable'\n\nimport {\n  Store,\n  PreloadedState,\n  StoreEnhancer,\n  Dispatch,\n  Observer,\n  ExtendState\n} from './types/store'\nimport { Action } from './types/actions'\nimport { Reducer } from './types/reducers'\nimport ActionTypes from './utils/actionTypes'\nimport isPlainObject from './utils/isPlainObject'\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param preloadedState The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nexport default function createStore<\n  S,\n  A extends Action,\n  Ext = {},\n  StateExt = never\n>(\n  reducer: Reducer<S, A>,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\nexport default function createStore<\n  S,\n  A extends Action,\n  Ext = {},\n  StateExt = never\n>(\n  reducer: Reducer<S, A>,\n  preloadedState?: PreloadedState<S>,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\nexport default function createStore<\n  S,\n  A extends Action,\n  Ext = {},\n  StateExt = never\n>(\n  reducer: Reducer<S, A>,\n  preloadedState?: PreloadedState<S> | StoreEnhancer<Ext, StateExt>,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext {\n  if (\n    (typeof preloadedState === 'function' && typeof enhancer === 'function') ||\n    (typeof enhancer === 'function' && typeof arguments[3] === 'function')\n  ) {\n    throw new Error(\n      'It looks like you are passing several store enhancers to ' +\n        'createStore(). This is not supported. Instead, compose them ' +\n        'together to a single function.'\n    )\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState as StoreEnhancer<Ext, StateExt>\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n\n    return enhancer(createStore)(\n      reducer,\n      preloadedState as PreloadedState<S>\n    ) as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.')\n  }\n\n  let currentReducer = reducer\n  let currentState = preloadedState as S\n  let currentListeners: (() => void)[] | null = []\n  let nextListeners = currentListeners\n  let isDispatching = false\n\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns The current state tree of your application.\n   */\n  function getState(): S {\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.getState() while the reducer is executing. ' +\n          'The reducer has already received the state as an argument. ' +\n          'Pass it down from the top reducer instead of reading it from the store.'\n      )\n    }\n\n    return currentState as S\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param listener A callback to be invoked on every dispatch.\n   * @returns A function to remove this change listener.\n   */\n  function subscribe(listener: () => void) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.')\n    }\n\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.subscribe() while the reducer is executing. ' +\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\n          'component and invoke store.getState() in the callback to access the latest state. ' +\n          'See https://redux.js.org/api/store#subscribelistener for more details.'\n      )\n    }\n\n    let isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      if (isDispatching) {\n        throw new Error(\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\n            'See https://redux.js.org/api/store#subscribelistener for more details.'\n        )\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      const index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n      currentListeners = null\n    }\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action: A) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' +\n          'Use custom middleware for async actions.'\n      )\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      )\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.')\n    }\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n\n    const listeners = (currentListeners = nextListeners)\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param nextReducer The reducer for the store to use instead.\n   * @returns The same store instance with a new reducer in place.\n   */\n  function replaceReducer<NewState, NewActions extends A>(\n    nextReducer: Reducer<NewState, NewActions>\n  ): Store<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.')\n    }\n\n    // TODO: do this more elegantly\n    ;((currentReducer as unknown) as Reducer<\n      NewState,\n      NewActions\n    >) = nextReducer\n\n    // This action has a similar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n    dispatch({ type: ActionTypes.REPLACE } as A)\n    // change the type of the store by casting it to the new store\n    return (store as unknown) as Store<\n      ExtendState<NewState, StateExt>,\n      NewActions,\n      StateExt,\n      Ext\n    > &\n      Ext\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    const outerSubscribe = subscribe\n    return {\n      /**\n       * The minimal observable subscription method.\n       * @param observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe(observer: unknown) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.')\n        }\n\n        function observeState() {\n          const observerAsObserver = observer as Observer<S>\n          if (observerAsObserver.next) {\n            observerAsObserver.next(getState())\n          }\n        }\n\n        observeState()\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable]() {\n        return this\n      }\n    }\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT } as A)\n\n  const store = ({\n    dispatch: dispatch as Dispatch<A>,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  } as unknown) as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\n  return store\n}\n"],"names":["$$observable","Symbol","observable","randomString","Math","random","toString","substring","split","join","ActionTypes","INIT","REPLACE","PROBE_UNKNOWN_ACTION","isPlainObject","obj","proto","Object","getPrototypeOf","getUndefinedStateErrorMessage","key","action","actionType","type","bindActionCreator","actionCreator","dispatch","args","apply","this","compose","funcs","length","arg","reduce","a","b","middlewares","createStore","reducer","store","Error","middlewareAPI","getState","chain","map","middleware","actionCreators","boundActionCreators","reducers","reducerKeys","keys","finalReducers","i","shapeAssertionError","finalReducerKeys","forEach","undefined","assertReducerShape","e","state","hasChanged","nextState","previousStateForKey","nextStateForKey","errorMessage","preloadedState","enhancer","arguments","currentReducer","currentState","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","slice","subscribe","listener","isSubscribed","push","index","indexOf","splice","listeners","replaceReducer","nextReducer","outerSubscribe","observer","TypeError","observeState","next","unsubscribe"],"mappings":"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"}